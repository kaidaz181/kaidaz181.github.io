import React, { useState, useEffect, useRef } from 'react';
import { AlertCircle, Heart, Zap, Trophy } from 'lucide-react';

const BLOCK_SIZE = 40;
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const GRAVITY = 0.6;
const JUMP_STRENGTH = -13;
const MOVE_SPEED = 4;
const GROUND_Y = 480;

const QUESTIONS = [
  {
    q: "What causes earthquakes?",
    options: ["Tectonic plate movement", "Heavy rain", "Wind", "Ocean waves"],
    correct: 0
  },
  {
    q: "What is the Richter scale used for?",
    options: ["Temperature", "Earthquake magnitude", "Wind speed", "Rainfall"],
    correct: 1
  },
  {
    q: "Which rock type is most stable during earthquakes?",
    options: ["Sand", "Gravel", "Bedrock", "Clay"],
    correct: 2
  },
  {
    q: "What should you do during an earthquake indoors?",
    options: ["Run outside", "Stand in doorway", "Drop, cover, hold on", "Use elevator"],
    correct: 2
  },
  {
    q: "What is liquefaction?",
    options: ["Water boiling", "Soil acting like liquid", "Ice melting", "Rock hardening"],
    correct: 1
  },
  {
    q: "Where do most earthquakes occur?",
    options: ["Plate boundaries", "Ocean centers", "Deserts", "Forests"],
    correct: 0
  },
  {
    q: "What is an aftershock?",
    options: ["First earthquake", "Smaller quake after main one", "Volcanic eruption", "Tsunami"],
    correct: 1
  },
  {
    q: "Which building material is most earthquake-resistant?",
    options: ["Unreinforced brick", "Wood frame", "Glass", "Clay"],
    correct: 1
  }
];

const BLOCK_TYPES = {
  STONE: { color: '#808080', stable: true },
  DIRT: { color: '#8B4513', stable: false },
  GRAVEL: { color: '#A9A9A9', stable: false },
  SAND: { color: '#F4A460', stable: false },
  LAVA: { color: '#FF4500', stable: true, deadly: true },
  BEDROCK: { color: '#2F4F4F', stable: true }
};

const EarthquakeSurvival = () => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('start');
  const [player, setPlayer] = useState({ x: 100, y: GROUND_Y - 120 - 30, vx: 0, vy: 0, onGround: false });
  const [cameraX, setCameraX] = useState(0);
  const [energy, setEnergy] = useState(100);
  const [health, setHealth] = useState(3);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [showQuestion, setShowQuestion] = useState(false);
  const [earthquake, setEarthquake] = useState(0);
  const [shakeOffset, setShakeOffset] = useState({ x: 0, y: 0 });
  const [blocks, setBlocks] = useState([]);
  const [keys, setKeys] = useState({});
  const [warning, setWarning] = useState('');
  const [score, setScore] = useState(0);
  const [earthquakeFrequency, setEarthquakeFrequency] = useState(15000);
  const animationFrameRef = useRef();
  const earthquakeTimerRef = useRef();

  const generateLevel = () => {
    const newBlocks = [];
    const levelWidth = 3000;
    const seed = Math.random();
    
    // Create ground
    for (let x = 0; x < levelWidth; x += BLOCK_SIZE) {
      newBlocks.push({ x, y: GROUND_Y, type: 'BEDROCK', id: `ground-${x}-${seed}`, falling: false });
    }
    
    // Starting safe platform
    for (let x = 0; x < 240; x += BLOCK_SIZE) {
      for (let i = 1; i <= 3; i++) {
        newBlocks.push({ x, y: GROUND_Y - (BLOCK_SIZE * i), type: 'STONE', id: `start-${x}-${i}-${seed}`, falling: false });
      }
    }
    
    // Generate level platforms with random seed
    let currentX = 280;
    while (currentX < levelWidth - 400) {
      const platformWidth = Math.floor(Math.random() * 4 + 3) * BLOCK_SIZE;
      const platformHeight = Math.floor(Math.random() * 3 + 2);
      const gap = Math.floor(Math.random() * 4 + 2) * BLOCK_SIZE;
      
      const types = ['DIRT', 'GRAVEL', 'SAND', 'STONE'];
      const typeWeights = [0.3, 0.25, 0.25, 0.2];
      const rand = Math.random();
      let type = types[0];
      let cumulative = 0;
      for (let i = 0; i < types.length; i++) {
        cumulative += typeWeights[i];
        if (rand < cumulative) {
          type = types[i];
          break;
        }
      }
      
      for (let x = currentX; x < currentX + platformWidth; x += BLOCK_SIZE) {
        for (let i = 1; i <= platformHeight; i++) {
          newBlocks.push({ x, y: GROUND_Y - (BLOCK_SIZE * i), type, id: `plat-${x}-${i}-${seed}`, falling: false });
        }
      }
      
      // Add lava hazard with variation
      if (Math.random() < 0.2 && currentX > 400) {
        const lavaCount = Math.floor(Math.random() * 2) + 1;
        for (let j = 0; j < lavaCount; j++) {
          newBlocks.push({ x: currentX + platformWidth + (j * BLOCK_SIZE), y: GROUND_Y - BLOCK_SIZE, type: 'LAVA', id: `lava-${currentX}-${j}-${seed}`, falling: false });
        }
      }
      
      currentX += platformWidth + gap;
    }
    
    // Goal platform
    for (let i = 1; i <= 5; i++) {
      newBlocks.push({ x: levelWidth - 200, y: GROUND_Y - (BLOCK_SIZE * i), type: 'BEDROCK', id: `goal-${i}-${seed}`, isGoal: i === 5, falling: false });
    }
    
    setBlocks(newBlocks);
  };

  useEffect(() => {
    if (gameState === 'playing') {
      generateLevel();
      setEarthquakeFrequency(15000);
    }
  }, [gameState]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === ' ') e.preventDefault();
      setKeys(prev => ({ ...prev, [e.key]: true }));
    };
    
    const handleKeyUp = (e) => {
      setKeys(prev => ({ ...prev, [e.key]: false }));
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    if (gameState !== 'playing' || showQuestion) return;

    const gameLoop = () => {
      setPlayer(prev => {
        let p = { ...prev };
        
        // Movement
        if (keys['ArrowLeft'] && energy > 0) {
          p.vx = -MOVE_SPEED;
          setEnergy(e => Math.max(0, e - 0.2));
        } else if (keys['ArrowRight'] && energy > 0) {
          p.vx = MOVE_SPEED;
          setEnergy(e => Math.max(0, e - 0.2));
        } else {
          p.vx *= 0.8;
        }
        
        // Jump
        if (keys[' '] && p.onGround) {
          p.vy = JUMP_STRENGTH;
          p.onGround = false;
        }
        
        // Apply gravity
        p.vy += GRAVITY;
        
        // Update position
        p.x += p.vx;
        p.y += p.vy;
        
        // Check collisions
        let isOnGround = false;
        const playerWidth = 30;
        const playerHeight = 30;
        
        for (const block of blocks) {
          // Skip falling blocks for collision
          if (block.falling) continue;
          
          const bx = block.x;
          const by = block.y;
          
          // Check collision
          if (p.x + playerWidth > bx && 
              p.x < bx + BLOCK_SIZE && 
              p.y + playerHeight > by && 
              p.y < by + BLOCK_SIZE) {
            
            // Deadly block
            if (BLOCK_TYPES[block.type].deadly) {
              setHealth(h => h - 1);
              return { x: 100, y: GROUND_Y - 120 - 30, vx: 0, vy: 0, onGround: false };
            }
            
            // Goal reached
            if (block.isGoal) {
              setGameState('won');
              return prev;
            }
            
            // Landing on top
            if (prev.y + playerHeight <= by + 5 && p.vy >= 0) {
              p.y = by - playerHeight;
              p.vy = 0;
              isOnGround = true;
            }
            // Hitting from below
            else if (prev.y >= by + BLOCK_SIZE - 5 && p.vy < 0) {
              p.y = by + BLOCK_SIZE;
              p.vy = 0;
            }
            // Side collision
            else {
              if (p.vx > 0) {
                p.x = bx - playerWidth;
              } else {
                p.x = bx + BLOCK_SIZE;
              }
              p.vx = 0;
            }
          }
        }
        
        p.onGround = isOnGround;
        
        // Fall off map
        if (p.y > CANVAS_HEIGHT + 100) {
          setHealth(h => h - 1);
          return { x: 100, y: GROUND_Y - 120 - 30, vx: 0, vy: 0, onGround: false };
        }
        
        return p;
      });
      
      // Update falling blocks
      setBlocks(prevBlocks => {
        return prevBlocks.map(block => {
          if (!block.falling) return block;
          
          const newBlock = { ...block };
          newBlock.y += 8;
          
          // Remove blocks that fall off screen
          if (newBlock.y > CANVAS_HEIGHT + 50) {
            return null;
          }
          
          return newBlock;
        }).filter(b => b !== null);
      });
      
      // Camera follow
      setCameraX(prev => {
        const target = player.x - CANVAS_WIDTH / 2;
        return prev + (target - prev) * 0.1;
      });
      
      // Energy check
      if (energy <= 15 && !showQuestion) {
        const randomQ = QUESTIONS[Math.floor(Math.random() * QUESTIONS.length)];
        setCurrentQuestion(randomQ);
        setShowQuestion(true);
      }
      
      animationFrameRef.current = requestAnimationFrame(gameLoop);
    };
    
    animationFrameRef.current = requestAnimationFrame(gameLoop);
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [gameState, showQuestion, energy, keys, blocks, player.x]);

  useEffect(() => {
    if (health <= 0) {
      setGameState('gameOver');
    }
  }, [health]);

  useEffect(() => {
    if (earthquake > 0) {
      const shakeInterval = setInterval(() => {
        setShakeOffset({
          x: (Math.random() - 0.5) * earthquake * 4,
          y: (Math.random() - 0.5) * earthquake * 4
        });
      }, 50);
      
      setTimeout(() => {
        setEarthquake(0);
        setShakeOffset({ x: 0, y: 0 });
        clearInterval(shakeInterval);
      }, 2000);
      
      return () => clearInterval(shakeInterval);
    }
  }, [earthquake]);

  // Random earthquake timer
  useEffect(() => {
    if (gameState !== 'playing') return;

    const triggerRandomEarthquake = () => {
      const intensity = Math.floor(Math.random() * 3) + 2;
      setEarthquake(intensity);
      setWarning(`Random earthquake! Intensity: ${intensity}`);
      
      setBlocks(prevBlocks => 
        prevBlocks.map(block => {
          if (BLOCK_TYPES[block.type].stable) return block;
          if (Math.random() < 0.3) {
            return { ...block, falling: true };
          }
          return block;
        })
      );
      
      setTimeout(() => setWarning(''), 2500);
      
      // Schedule next earthquake
      const nextDelay = Math.random() * earthquakeFrequency + 5000;
      earthquakeTimerRef.current = setTimeout(triggerRandomEarthquake, nextDelay);
    };

    // Start the timer
    const initialDelay = Math.random() * 10000 + 8000;
    earthquakeTimerRef.current = setTimeout(triggerRandomEarthquake, initialDelay);

    return () => {
      if (earthquakeTimerRef.current) {
        clearTimeout(earthquakeTimerRef.current);
      }
    };
  }, [gameState, earthquakeFrequency]);

  const handleAnswer = (index) => {
    if (index === currentQuestion.correct) {
      setEnergy(100);
      setScore(s => s + 10);
      setShowQuestion(false);
    } else {
      const intensity = Math.min(Math.floor(Math.random() * 4) + 5, 10);
      setEarthquake(intensity);
      setWarning(`Wrong answer! Major earthquake! Intensity: ${intensity}`);
      
      // Increase frequency of random earthquakes
      setEarthquakeFrequency(prev => Math.max(5000, prev - 2000));
      
      // Make MORE blocks fall when wrong
      setBlocks(prevBlocks => 
        prevBlocks.map(block => {
          if (BLOCK_TYPES[block.type].stable) return block;
          if (Math.random() < 0.6) {
            return { ...block, falling: true };
          }
          return block;
        })
      );
      
      setShowQuestion(false);
      setTimeout(() => setWarning(''), 3000);
    }
  };

  // Render canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || gameState !== 'playing') return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.save();
    ctx.translate(shakeOffset.x, shakeOffset.y);
    
    // Sky
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw blocks
    blocks.forEach(block => {
      const x = block.x - cameraX;
      const y = block.y;
      
      if (x > -BLOCK_SIZE && x < CANVAS_WIDTH + BLOCK_SIZE) {
        const blockType = BLOCK_TYPES[block.type];
        
        // Add transparency to falling blocks
        if (block.falling) {
          ctx.globalAlpha = 0.7;
        }
        
        ctx.fillStyle = blockType.color;
        ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
        
        // Unstable block indicator
        if (!blockType.stable && !blockType.deadly && !block.falling) {
          ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 4]);
          ctx.strokeRect(x + 3, y + 3, BLOCK_SIZE - 6, BLOCK_SIZE - 6);
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
        }
        
        ctx.strokeStyle = '#000';
        ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
        
        if (block.isGoal) {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('üèÅ', x + BLOCK_SIZE / 2, y + 28);
        }
        
        ctx.globalAlpha = 1.0;
      }
    });
    
    // Draw player
    const playerX = player.x - cameraX;
    ctx.fillStyle = '#FF6B6B';
    ctx.fillRect(playerX, player.y, 30, 30);
    ctx.strokeStyle = '#8B0000';
    ctx.lineWidth = 2;
    ctx.strokeRect(playerX, player.y, 30, 30);
    
    ctx.restore();
  });

  const resetGame = () => {
    setGameState('playing');
    setHealth(3);
    setEnergy(100);
    setScore(0);
    setPlayer({ x: 100, y: GROUND_Y - 120 - 30, vx: 0, vy: 0, onGround: false });
    setCameraX(0);
    setEarthquake(0);
    setWarning('');
    setEarthquakeFrequency(15000);
  };

  if (gameState === 'start') {
    return (
      <div className="w-full h-screen bg-gradient-to-b from-blue-900 to-gray-900 flex items-center justify-center">
        <div className="bg-white rounded-lg p-8 max-w-2xl shadow-2xl">
          <h1 className="text-4xl font-bold mb-4 text-center text-red-600">üåã Earthquake Survival üåã</h1>
          <div className="space-y-4 mb-6">
            <p className="text-lg">Survive the earthquake and reach the goal!</p>
            <div className="bg-gray-100 p-4 rounded">
              <h3 className="font-bold mb-2">How to Play:</h3>
              <ul className="space-y-1 text-sm">
                <li>‚¨ÖÔ∏è ‚û°Ô∏è Arrow keys to move (uses energy)</li>
                <li>SPACE to jump</li>
                <li>Answer questions correctly to restore energy</li>
                <li>Wrong answers cause earthquakes!</li>
              </ul>
            </div>
            <div className="bg-yellow-100 p-4 rounded border-2 border-yellow-500">
              <h3 className="font-bold mb-2">‚ö†Ô∏è Block Types:</h3>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div><span className="font-bold text-red-600">Unstable (yellow dashes):</span> Dirt, Gravel, Sand</div>
                <div><span className="font-bold text-green-600">Stable:</span> Stone, Bedrock</div>
                <div><span className="font-bold text-orange-600">Deadly:</span> Lava (red blocks)</div>
              </div>
            </div>
          </div>
          <button 
            onClick={() => setGameState('playing')}
            className="w-full bg-red-600 text-white py-3 rounded-lg font-bold text-xl hover:bg-red-700"
          >
            Start Game
          </button>
        </div>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div className="w-full h-screen bg-gradient-to-b from-red-900 to-gray-900 flex items-center justify-center">
        <div className="bg-white rounded-lg p-8 max-w-md shadow-2xl text-center">
          <h1 className="text-4xl font-bold mb-4 text-red-600">Game Over!</h1>
          <p className="text-2xl mb-4">Score: {score}</p>
          <p className="mb-6">The earthquakes were too strong!</p>
          <button 
            onClick={resetGame}
            className="w-full bg-red-600 text-white py-3 rounded-lg font-bold hover:bg-red-700"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  if (gameState === 'won') {
    return (
      <div className="w-full h-screen bg-gradient-to-b from-green-900 to-gray-900 flex items-center justify-center">
        <div className="bg-white rounded-lg p-8 max-w-md shadow-2xl text-center">
          <Trophy className="w-20 h-20 mx-auto mb-4 text-yellow-500" />
          <h1 className="text-4xl font-bold mb-4 text-green-600">You Survived!</h1>
          <p className="text-2xl mb-4">Final Score: {score}</p>
          <p className="mb-6">You made it to safety!</p>
          <button 
            onClick={resetGame}
            className="w-full bg-green-600 text-white py-3 rounded-lg font-bold hover:bg-green-700"
          >
            Play Again
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-screen bg-gray-900 flex flex-col items-center justify-center p-4">
      <div className="mb-4 flex gap-6 text-white">
        <div className="flex items-center gap-2">
          <Heart className="text-red-500" />
          <span className="font-bold">Health: {health}</span>
        </div>
        <div className="flex items-center gap-2">
          <Zap className="text-yellow-500" />
          <span className="font-bold">Energy: {Math.round(energy)}%</span>
        </div>
        <div className="font-bold">Score: {score}</div>
      </div>
      
      {warning && (
        <div className="mb-4 bg-red-600 text-white px-4 py-2 rounded-lg font-bold flex items-center gap-2">
          <AlertCircle />
          {warning}
        </div>
      )}
      
      <canvas 
        ref={canvasRef} 
        width={CANVAS_WIDTH} 
        height={CANVAS_HEIGHT}
        className="border-4 border-gray-700 shadow-2xl"
      />
      
      {showQuestion && currentQuestion && (
        <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center">
          <div className="bg-white rounded-lg p-8 max-w-lg">
            <h2 className="text-2xl font-bold mb-4">{currentQuestion.q}</h2>
            <div className="space-y-2">
              {currentQuestion.options.map((option, index) => (
                <button
                  key={index}
                  onClick={() => handleAnswer(index)}
                  className="w-full bg-blue-500 hover:bg-blue-600 text-white py-3 rounded-lg font-bold text-left px-4"
                >
                  {option}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
      
      <div className="mt-4 text-white text-center text-sm">
        <p>Use ‚¨ÖÔ∏è ‚û°Ô∏è to move ‚Ä¢ SPACE to jump</p>
        <p className="text-yellow-400">Low energy? Answer questions to recharge!</p>
      </div>
    </div>
  );
};

export default EarthquakeSurvival;
